5/27/2019

This is supposed to be a chapter 1 - 13 review. But nothing really happens in the first three
chpaters. 
chapter 1 explains what power shell is and how to install it and find out which version is installed
chapter 2 is about various methods of running commands and console settings
chapter 3 is about the help system. actually the whole book has an emphasis on using the help system. which is good because it sort of future-proofs

so really it's chapters 4 - 13 review

chapter 4

chapter 4 covers a few basic commands and how they work
actually some stuff aobut aliases which I had forgotten about.
that importing/exporting aliases for later use

looks like you can query what aliases may exist for commands, like get-service:
get-alias -Definition "Get-Service"
would return that there's an alias called "gsv"

I remember thinking aliases in PS were different than the aliases of the bash shell
not sure if I remember why i thought that.

as i recall aliases in Bash (and X) are more used...okay i don't remember at all. I think it is like a 
dir for ls -l thing. which isn't quite the same. I think PS aliases can be used like that. just not exactly

chapter 4 also talks about "positional parameters"
which is the idea of just putting in a value for a paremeter rather than specifying the parameter ten the value

an easy example is a move command:
move file1.txt \users\tildes
is really a shortcut for

move -path c:\file1.txt -Destination \users\tildes

the path and destination parameters will always be in the same place.. or position... so just putting in the 
values in those positions is just as acceptable 

apparently get-childitem is the PS way of doing a DIR command
and 
get-childitem c:\users
is the short way of doing
get-childitem -path c:\users

a feature I completely forgot about...show-command

a GUI for filling out parameters and options for a cmdlet
which can then be run direct from the GUI and/or the command can be copied to the clipboard for copy/paste later

I tried 
Show-Command Invoke-Command
it reminded me that the "scriptblock" is what the thing is really called
i think comptuername was used in place of scriptblock
kind of confusing
anyway show-command seems great

looks like
new-psdrive -persistent
is ps equiv of 
net use 
for mapping

one that isn't used in these first 13 chapters is variables with the $ sign
but chapter 4 actually mentions an example in the "will old commands run" section
as in:
$exe = \some\path\to\exe
$host = "thinkcentre1"
$user = "joe"
$password = "password"
$backuptype = "incremental " & $exe -h $host -u $user -p $password 

well that's the idea anyway. concontenating a string as with any language
just using $ to define and designate the variables

very simple yet effective

oh, i thought the & ampersand was a concatenation thing but i guess it's an "invocation operator"
to pass in the exe along with the parameters
the & isn't really covered that much either after chapter 4. maybe later on

################################### chapter 5: providers

lets move on to chapter 5: i'm actually still not sure what these are
and they're not really mentioned that much outside of chapter 5

A PSProvider is an "adapter" that "takes some kind of data storage" and "makes it look like disk drive"

Ya, i got no idea what that means. I mean i kind of have an idea. But not really

get-psprovider lists some possible providers and their "capabilities" and "drives"

the FileSystem provider for instance has "capabilities" of:
Filter, ShouldProcess, Credentials
and "drives" on this local PC of
 {C, P}

 Interestingly, enabling Remoting provides a new PSProvider called WSMan
 why this wasn't mentioned in chapter 13, all about Remoting, I have no idea

 looking at provider info samples:
 #############

 Name                 Capabilities                                                              Drives
----                 ------------                                                              ------
Registry             ShouldProcess, Transactions                                               {HKLM, HKCU}
Alias                ShouldProcess                                                             {Alias}
Environment          ShouldProcess                                                             {Env}
FileSystem           Filter, ShouldProcess, Credentials                                        {C, P}
Function             ShouldProcess                                                             {Function}
Variable             ShouldProcess                                                             {Variable}
WSMan                Credentials                                                               {WSMan}
#############

"ShouldProcess" seems to indicate inclusion of -whatif and -ocnfirm parameters for testing before executing

filter just means it has the -filter parameter

Credentials means alt Credentials can be specified

Transactions - means you can use a provider to "make several changes" then "either roll back or commit to those changes". Not even sure what that means

get-psdrive is used as an example. I ran this and got this back.

Name           Used (GB)     Free (GB) Provider      Root                      CurrentLocation
----           ---------     --------- --------      ----                      ---------------
Alias                                  Alias
C                  62.89        175.04 FileSystem    C:\                      Windows\system32
Cert                                   Certificate   \
Env                                    Environment
Function                               Function
HKCU                                   Registry      HKEY_CURRENT_USER
HKLM                                   Registry      HKEY_LOCAL_MACHINE
P                 452.16       1410.85 FileSystem    P:\                      Repos\PowerShellFun
Variable                               Variable
WSMan                                  WSMan
############# ############# ############# ############# #############

this may or may not be easy to follow:
- the psprovider "adapts the data store"
- the psdrive "makes it accessible"
- cmdlets allow for seeing and manipulating data exposed by each psdrive

generally cmdlets that are used with have "item" some where in them
as demonstrated by get-command -noun *item*:

CommandType     Name                                               Version    Source
-----------     ----                                               -------    ------
Function        Get-DAEntryPointTableItem                          1.0.0.0    DirectAccessClientComponents
Function        Get-TestDriveItem                                  3.4.0      Pester
Function        New-DAEntryPointTableItem                          1.0.0.0    DirectAccessClientComponents
Function        Remove-DAEntryPointTableItem                       1.0.0.0    DirectAccessClientComponents
Function        Rename-DAEntryPointTableItem                       1.0.0.0    DirectAccessClientComponents
Function        Reset-DAEntryPointTableItem                        1.0.0.0    DirectAccessClientComponents
Function        Set-DAEntryPointTableItem                          1.0.0.0    DirectAccessClientComponents
Cmdlet          Clear-Item                                         3.1.0.0    Microsoft.PowerShell.Management
... (snipped for brevity) ...
Cmdlet          New-Item                                           3.1.0.0    Microsoft.PowerShell.Management
Cmdlet          New-ItemProperty                                   3.1.0.0    Microsoft.PowerShell.Management
Cmdlet          Remove-Item                                        3.1.0.0    Microsoft.PowerShell.Management
Cmdlet          Remove-ItemProperty                                3.1.0.0    Microsoft.PowerShell.Management
Cmdlet          Rename-Item                                        3.1.0.0    Microsoft.PowerShell.Management
Cmdlet          Rename-ItemProperty                                3.1.0.0    Microsoft.PowerShell.Management
Cmdlet          Set-Item                                           3.1.0.0    Microsoft.PowerShell.Management
Cmdlet          Set-ItemProperty                                   3.1.0.0    Microsoft.PowerShell.Management
############# ############# ############# ############# #############

starting with FileSystem PSProvider...

files and folders are both generically referred as "items" and are both objects (thus the "item" for the noun)

items often have properties...

items within container items, like folders/files inside a folder, are "child items"

more clear layout:

- verbs: apply to all items (files/folders) and to item properties (date stamps, read-only etc)
 verb examples: clear, copy, get, move, new, remove, rename, set 
 - item nouns: refer to individual objects (files/folders)
 - ItemProperty noun: attributes and date created, read-only, length etc
 - childitem noun: items within an item (subfolders/files)

 even though the registry seems to have similarities with the files system
 with registry keys and values being like folders/files
the registry and other psproviders can be and often are quite different

############# ############# The PS version of things ############# #############

in place of "cd", PS uses set-location:
set-location -Path c:\Windows

similarly, in place of md/mkdir PS uses new-item:
new-item testfolder

the main reason to learn these generic PS versions of the commands is because
they'll work on both the file system as well as other psproviders like the registry

in contexts besides the file system characters like * and ? can be used in names etc
to escape those instead of using them as wildcards the -literalpath paraemter is used

############# ############# Using registery provider in particular ############# #############

first we change the HKCU "drive" with set-location:

"set-location -path hkcu:"

then change the right location within that part of the registry:

set-location -path software

then the get-childitem

I actually tried this with "cd" and "dir" and it seemed to have produced the same results
so i guess it's not that big of a deal 

when i did the dir/get-childitem it lets me know the context I'm in:

Hive: HKEY_CURRENT_USER\Software

so change the a specific location inside the registry: 

cd Microsoft\Windows

and chagne a specific key from 1 to 0 with set-ItemProperty:

Set-ItemProperty -Path .\DWM\ -PSProperty EnableAeroPeek -Value 0

i actually changed over to thinkcentre1 for a remote session:
Enter-PSSession -ComputerName ThinkCentre1
then did the same thing in the registry context and well i didn't get errors anyway 
and the value of aeropeek is 0 now instead of 1 so i guess it's good

I tried some random other PSproviders just to see what happens
i wasn't sure how to do it at first but

set-location variable:

did apparently change me to the variable context
just as
set-location WSMan: 
did indeed change my context to that, though in case of WSMan i didn't know how to do anything further

I also learned that trailing colon is important as it won't work without it

when i changed to the variable: context and did a dir i did get a bunch of variables
no idea if these are the kind i can change. they seem system-related
I'm sure I could look at the attributes of each to see which are read-only and which aren't 

################################### chapter 6: pipelines

this chapter seems as much about exporting to different formats as it is about piping 
things to other things

so it's obvious what's happening in this context:
take output of get-process and "pipe it" into a csv file
which PS is smart enough to know how to do automatically

get-process | export-csv procs.csv

Alright, that's cool 

makes me wonder if i could tell invoke-command to do that to 3 different PCs at once and store the result locally
sounds like literally the thing invoke-command was made for actually, so probably

the inverse of course is import-csv

there's also export-xml which seems similar to the csv one
also it's technically "CliXML" format but close enough.
so export-clixml and import-clixml are really the commands

and compare-object (alias diff) 
can be used to compare the local PC with the snapshot PC to see the difference

example:
diff -reference (import-clixml reference.xml) -difference (get-process) -property Name

diff, as the object part implies, doesn't really do well with actual text files


there's also convertto-html, which as the name implies merely converts, different than exporting so that part has to done with pipes:
get-service | converto-html | out-file services.html

there's also convertto-xml and convertto-csv which is used in the smae way 

the output produces the file in the right format instead to the screen and the different columns and amount of information can be customized

############# killing/stopping processes

the take away is cmdlets with same noun - like process - often match up each other
as in getting and stopping a process:
get-process -name notepad | stop-process
same get could be said for cmdlets with service in the name
stop/start/set-service

################################### chapter 7: adding commands

section 7.1 draws the similarities between PS and the "MMC Console" snap-in system. and how it kind of moved away from that.
7.2 mentions product-specific managment shells. /skip/

7.3 covers "PSSnappins" which is "something MS is moving away from. I think i on't worry about it.

7.4 is about modules, where to find modules, where modules are stored by default...may be of interest later

7.7 just continues with modules and getting help for new modules. pretty standard stuff really

7.8 is about having modules auto-load when PS opened. Which actually could be helpful in theory. at a later date. 
not enough detail for it to really be worth mentioning right now

7.9 is the first direct mention of the aptitude-equivalent package manager for PS v5 call installe 
install-module
actually it comes for nuget and a couple of other technologies
but it talks about powershellgallery.com
which isn't even the most popular repo and hasn't been for a while.
it's got that it's mentioned though even if the few paragraphs aren't that useful

and that's it. that's all for chapter 7

################################### chapter 8: all about objects

this seems to be more a conceptual/theoretical sort of chapter, at least first

the get-process command contsructs a table in memory but not all the information in included in the output

as defined by the book at least:

a "table row" is an "object" e.g. a single process or service

a table column is a "property/attributes". this is a piece of information about an object e.g. a porcdcess ID or service status

an "action" is a "method" in object-speak such as killing a process or starting a service

a colleciton - ais entire set of objects, collectivevly this is the entire table worth of output 

these objects/properties/methods/collections are all together called "members" (everything is PS is singular, so get-member)

the "advantage" of objects versus the text/grep way: getting a speficic process name and killing it
in PS just involves getting the column number and telling it to kill that process
no need to parse text line by line


the command used to get more information on on an object is get-member (e.g. gm)

the output of a pipe to GM will show some types of proprties including

scriptproperty
property
noteproperty
aliasproperty

a property is there to contain a value
a name property for instance might be notepad
most properties are going to be read-only 

methods may not need to be used directly as there are often cmdlets to perform those particular functions

one example is killing a process:
get-process -name notepad | stop-process
vs
stop-process -name notepad

i think those are both the cmdlet method actually but lets say just use cmdlet method for now

sorting objects...

to sort processes but the biggest consumers of virtual memory, 
the sort object would be used:
get-process | sort-object -property -VM

then a slight variant of the command to sort by descending:
get-process | sort-object -property -VM -desc

or another variant, by first virtual memory then by ID:
get-process | sort-object -property -VM,ID -desc

there's also select-object

it takes in object via the pipeline, along with properties that should be displayed as output
sort of a way of "trimming" down all the available information

for instance this demonstrates the point:
Get-Process | Select-Object -Property Name,ID,VM,PM


the first example given for objects interacting is:
get-process |
sort-boject VM -desc |
out-file c:\procs.txt

this sends the output of get-process to sort object which sorts by VM descending
then sends the output to a text file with out-file

the next example does it a little differnetly in that 
the first two steps are the same but
select-object specifies only a few properties of the process object
which effectively makes a new "custom object" called a PSObject.
It copies over the properties specified for output to the PSObject:

Get-Process |
Sort-Object VM -Descending | 
Select-Object Name,ID,VM

the output of this won't be as nice as a normal get-process because PS doesn't have any formatting information on this newly
generated PSObject. It tries to take a best guess

The get-member for this isn't exactly as the book describes but gets the poit across:

   TypeName: Selected.System.Diagnostics.Process

Name        MemberType   Definition
----        ----------   ----------
Equals      Method       bool Equals(System.Object obj)
GetHashCode Method       int GetHashCode()
GetType     Method       type GetType()
ToString    Method       string ToString()
Id          NoteProperty int Id=8120
Name        NoteProperty string Name=SearchUI
VM          NoteProperty long VM=2238794711040


it's really just trying at a best guess for the custom object


tracking object types via gm is a good debugging/troubleshooting technique

################################### chapter 9: Piping 2: the pipening (also pipeline parameter bindng)

using "command A" as the first command 
and
"command B" as the second one 
for reference...

When two cmdlets are piped together PS has to figure out how to get the output of the first to the input of the second 


example:

with a text file of PC names, one per line, called computers.txt

this command:
get-content .\computers.txt | get-service

takes a computer from the text file on places it on the pipe line 

but PS has to figure out how to get that get-content output over to get-service 
that process of figuring out how to do that is "pipeline prameter binding"

PS has two methods of of getting the output of get-content on to a parameter of get-service:

ByValue
and
ByPropertyName
(these are both types of parameter binding)

9.3: Piping by value

########### ByValue

PS will look at the object produced by command A and see whether any parameter of command B can acceptable
that object type

this can be determined manually by piping command A to GM and comparing this to the "-full" of the help for command B

in the get content example, get-content is producing objects of type system.string (or just "string") 

looking at the help for get-service show that there is a name pameter and it is does accept string input by value

but looking at the help this name paraemter actually refrrs to service names, not PC names
so the sample command would be sending computer names in to a service name parameter 

Only one paraemter can accept a given type of object from the pipeline ByValue

that means that -name parameter of get-service is the only one that can accept the string byvalue via the pipeline 

########### another example (still byvalue)

get-process -name note* | stop-process

doing the same pipe to gm/full help comparison

get-process produces objects of system.Diagnostics.process
stop-process can accept that kind of object from the pipeline byvalue via it's -inputobject parameter  
this would indicate that command A retrieves the process objects while command b can take those objects and kill them

this also helps to keep in mind that cmdlets that share the same noun (the -process part) can usually pipe to each other 

########### yet another example (switching to ByPropertyName)

get-service -name s* | stop-process

this doesn't make sense on the fface of it because of the mixture of services with processes...

get-service produces objects of serviceController type but stop-process doesn't have any parameters that accept 
serviceController objects

this is where the "fall back" of ByPropertyName comes in

doing the standard GM of command A for comparison with the full help of command B
shows that there is one parameter whose name corresponds to a paremeter with command B

THE BOOK EMPHASIZES  THAT THE ONLY THEING ACTUALLING HAPPENING HERE IS A NAME MATCH BETWEEN A PROPERT NAME AND A PARAMETER NAME
a very simple character match with one to the other and that's it

this is of course limited by whether or not the "accept pipeline input" line is both true and "ByPropertyName" is listed

since this is in fact the case between get-service and stop-process...
the connection is possible...

Having said all that even though there's a name/name match between property and -name the second one is expecting something else 
entirely (process names) then what the first one is sending over (service names)

(pg. 108)